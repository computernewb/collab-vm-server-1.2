{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Collab3 The next-generation of CollabVM. This site contains work in progress documentation for the Collab3 monorepo, and documentation for the individual components it builds. It is in no way authoritative (until this disclaimer is removed), and may change unexpectedly during early development. Quick Links Building Collab3 About Collab3 Setup","title":"Home"},{"location":"#collab3","text":"The next-generation of CollabVM. This site contains work in progress documentation for the Collab3 monorepo, and documentation for the individual components it builds. It is in no way authoritative (until this disclaimer is removed), and may change unexpectedly during early development.","title":"Collab3"},{"location":"#quick-links","text":"Building Collab3 About Collab3 Setup","title":"Quick Links"},{"location":"about/","text":"The Collab3 monorepo is a fully rewritten version of the CollabVM project. Philosophy One monorepo for everything in the project Checking out the repository shouldn't be painful Better development experience (one clone command versus 3-4...) No project submodules (less time needed to update a superproject, more time to write code) Fast, readable, and modular modern C++20 code Hacking on the codebase shouldn't be a daunting task Awaitable + coroutines really help with this on the ASIO front Development & additional features encouraged by core developers (hopefully made more possible by code clarity/design) Source Structure .github/ -> Github files cmake/ -> Global CMake includes docs/ -> MkDocs documentation files lib/ -> Project libraries protocol/ -> Shared (between agent, server, webapp) protocol files server/ -> Collab3 server api/ -> API module core/ -> Core library config/ http/ util/ host/ -> Temp host webapp/ -> Webapp","title":"About"},{"location":"about/#philosophy","text":"One monorepo for everything in the project Checking out the repository shouldn't be painful Better development experience (one clone command versus 3-4...) No project submodules (less time needed to update a superproject, more time to write code) Fast, readable, and modular modern C++20 code Hacking on the codebase shouldn't be a daunting task Awaitable + coroutines really help with this on the ASIO front Development & additional features encouraged by core developers (hopefully made more possible by code clarity/design)","title":"Philosophy"},{"location":"about/#source-structure","text":".github/ -> Github files cmake/ -> Global CMake includes docs/ -> MkDocs documentation files lib/ -> Project libraries protocol/ -> Shared (between agent, server, webapp) protocol files server/ -> Collab3 server api/ -> API module core/ -> Core library config/ http/ util/ host/ -> Temp host webapp/ -> Webapp","title":"Source Structure"},{"location":"building/","text":"Compiling the Collab3 monorepo code is fairly easy. Notice Windows is not supported by the Collab3 developers, and the project will not configure if targeting a Windows platform. This is an intentional change, and it will not be reverted. Dependencies GCC 11+ or Clang 14+ are recommended compiler versions, however newer versions are acceptable too. Libraries: Boost 1.75 or above fmt spdlog You can use either system library versions (if preferred) or use Conan. TODO: it is planned to use conan by default, and have system libraries be opt-in. Building Collab3 Monorepo C++ Code The general formula is: $ cmake -B build --preset $PRESET $ cmake --build build # ... # profit? where $PRESET can be: release : Release build debug : Debug build debug-asan : Debug build (with AddressSanitizer enabled) debug-tsan : Debug build (with ThreadSanitizer enabled) debug-ubsan : Debug build (with UBSanitizer enabled) There are also others, but they are only for use by our CI, and shouldn't be used by users directly. For now, you'll get one collab3-host executable in the build root. This is the one you should run. Building Collab3 Monorepo Documentation Note that usually you won't have to do this, as the web documentation will update upon any changes to the documentation in the master branch. For development/local preview purposes, though: Prerequisites mkdocs Run mkdocs build . The resulting output will be in site/ , and you can host this wherever you want.","title":"Building Collab3"},{"location":"building/#notice","text":"Windows is not supported by the Collab3 developers, and the project will not configure if targeting a Windows platform. This is an intentional change, and it will not be reverted.","title":"Notice"},{"location":"building/#dependencies","text":"GCC 11+ or Clang 14+ are recommended compiler versions, however newer versions are acceptable too. Libraries: Boost 1.75 or above fmt spdlog You can use either system library versions (if preferred) or use Conan. TODO: it is planned to use conan by default, and have system libraries be opt-in.","title":"Dependencies"},{"location":"building/#building-collab3-monorepo-c-code","text":"The general formula is: $ cmake -B build --preset $PRESET $ cmake --build build # ... # profit? where $PRESET can be: release : Release build debug : Debug build debug-asan : Debug build (with AddressSanitizer enabled) debug-tsan : Debug build (with ThreadSanitizer enabled) debug-ubsan : Debug build (with UBSanitizer enabled) There are also others, but they are only for use by our CI, and shouldn't be used by users directly. For now, you'll get one collab3-host executable in the build root. This is the one you should run.","title":"Building Collab3 Monorepo C++ Code"},{"location":"building/#building-collab3-monorepo-documentation","text":"Note that usually you won't have to do this, as the web documentation will update upon any changes to the documentation in the master branch. For development/local preview purposes, though:","title":"Building Collab3 Monorepo Documentation"},{"location":"building/#prerequisites","text":"mkdocs Run mkdocs build . The resulting output will be in site/ , and you can host this wherever you want.","title":"Prerequisites"},{"location":"devguidelines/","text":"Development guidelines These are some guidelines for code which is part of the repo. JavaScript/TypeScript To be written, but for now, just don't write some IE8 tier stuff and you'll be fine. C++ Formatting Use clang-format. Naming Use .cpp for source files, .hpp for headers, and .cppm for module interface units. Inline functions do not need another implementation file, and inline class member functions should be implemented inside the class body. Function and type names should be in PascalCase. Variable names are camelCase. Underscores should only be used very rarely for private/introspection only fields which need to be public (for instance; in classes which need to stay POD), as they risk UB. Class members have no special prefix. Example (unformatted because I'm lazy): struct MyStructure { void DoThing(); private: std::uint32_t thing{}; std::uint32_t otherThing{}; }; void FreeFunction(); Language Subset The Collab3 C++ code uses the C++ language, obviously, but we do not use some features of the C++ language. The later sections describe our C++ language subset in depth. Exceptions Exceptions and the throw keyword are banned in the collab3 server code. Rather: Non-fatal errors are collab3::core::Result<Value, Error> This currently is an alias to tl::expected . We do not use std::error_code , as it's pretty awful and also requires polymorphism & other iffy things. core::Error<EC> & core::ErrorCategory<EC> are our reimplementation, which makes sizeof(Error<EC>) == sizeof(EC) . Fatal/unrecoverable errors should call collab3::core::Panic() with an optional message. The affected application will shut down with a message and print a stack trace (with symbolized names in Debug builds). COLLAB3_CORE_ASSERT(...) and COLLAB3_CORE_VERIFY(...) both call Panic() upon failure. _EXPECT(..., Error) variants will instead return a Result initialized with an Error . Exceptions to this rule: - Constant expressions are allowed to use the throw keyword to induce compile time errors, as this is pretty much the only way to cleanly do so. Any code which currently throws before this rule was documented (refactor it out!!!) RTTI RTTI is allowed, but mostly because it'd be annoying to have to ban it.","title":"Development Guidelines"},{"location":"devguidelines/#development-guidelines","text":"These are some guidelines for code which is part of the repo.","title":"Development guidelines"},{"location":"devguidelines/#javascripttypescript","text":"To be written, but for now, just don't write some IE8 tier stuff and you'll be fine.","title":"JavaScript/TypeScript"},{"location":"devguidelines/#c","text":"","title":"C++"},{"location":"devguidelines/#formatting","text":"Use clang-format.","title":"Formatting"},{"location":"devguidelines/#naming","text":"Use .cpp for source files, .hpp for headers, and .cppm for module interface units. Inline functions do not need another implementation file, and inline class member functions should be implemented inside the class body. Function and type names should be in PascalCase. Variable names are camelCase. Underscores should only be used very rarely for private/introspection only fields which need to be public (for instance; in classes which need to stay POD), as they risk UB. Class members have no special prefix. Example (unformatted because I'm lazy): struct MyStructure { void DoThing(); private: std::uint32_t thing{}; std::uint32_t otherThing{}; }; void FreeFunction();","title":"Naming"},{"location":"devguidelines/#language-subset","text":"The Collab3 C++ code uses the C++ language, obviously, but we do not use some features of the C++ language. The later sections describe our C++ language subset in depth.","title":"Language Subset"},{"location":"devguidelines/#exceptions","text":"Exceptions and the throw keyword are banned in the collab3 server code. Rather: Non-fatal errors are collab3::core::Result<Value, Error> This currently is an alias to tl::expected . We do not use std::error_code , as it's pretty awful and also requires polymorphism & other iffy things. core::Error<EC> & core::ErrorCategory<EC> are our reimplementation, which makes sizeof(Error<EC>) == sizeof(EC) . Fatal/unrecoverable errors should call collab3::core::Panic() with an optional message. The affected application will shut down with a message and print a stack trace (with symbolized names in Debug builds). COLLAB3_CORE_ASSERT(...) and COLLAB3_CORE_VERIFY(...) both call Panic() upon failure. _EXPECT(..., Error) variants will instead return a Result initialized with an Error . Exceptions to this rule: - Constant expressions are allowed to use the throw keyword to induce compile time errors, as this is pretty much the only way to cleanly do so. Any code which currently throws before this rule was documented (refactor it out!!!)","title":"Exceptions"},{"location":"devguidelines/#rtti","text":"RTTI is allowed, but mostly because it'd be annoying to have to ban it.","title":"RTTI"},{"location":"usage/","text":"TODO This page is under construction","title":"Collab3 Setup"},{"location":"usage/#todo","text":"This page is under construction","title":"TODO"}]}