{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Collab3 The next-generation of CollabVM. This site contains work in progress documentation for the Collab3 monorepo, and documentation for the individual components it builds. It is in no way authoritative (until this disclaimer is removed), and may change unexpectedly during early development. Quick Links Building Collab3 About Collab3 Setup","title":"Home"},{"location":"#collab3","text":"The next-generation of CollabVM. This site contains work in progress documentation for the Collab3 monorepo, and documentation for the individual components it builds. It is in no way authoritative (until this disclaimer is removed), and may change unexpectedly during early development.","title":"Collab3"},{"location":"#quick-links","text":"Building Collab3 About Collab3 Setup","title":"Quick Links"},{"location":"about/","text":"The Collab3 monorepo is a fully rewritten version of the CollabVM project. Philosophy One monorepo for everything in the project Checking out the repository shouldn't be painful Better development experience (one clone command versus 3-4...) No project submodules (less time needed to update a superproject, more time to write code) Fast, readable, and modular modern C++20 code Hacking on the codebase shouldn't be a daunting task Awaitable + coroutines really help with this on the ASIO front Development & additional features encouraged by core developers (hopefully made more possible by code clarity/design) Microservices for each core part of the Collab3 server Currently supported by design with modular server/api, server/... libraries Source Structure .github/ -> Github files cmake/ -> Global CMake includes docs/ -> MkDocs documentation files lib/ -> Project libraries protocol/ -> Shared (between agent, server, webapp) protocol files server/ -> Collab3 server api/ -> API module core/ -> Core library config/ http/ util/ host/ -> Temp host webapp/ -> Webapp","title":"About"},{"location":"about/#philosophy","text":"One monorepo for everything in the project Checking out the repository shouldn't be painful Better development experience (one clone command versus 3-4...) No project submodules (less time needed to update a superproject, more time to write code) Fast, readable, and modular modern C++20 code Hacking on the codebase shouldn't be a daunting task Awaitable + coroutines really help with this on the ASIO front Development & additional features encouraged by core developers (hopefully made more possible by code clarity/design) Microservices for each core part of the Collab3 server Currently supported by design with modular server/api, server/... libraries","title":"Philosophy"},{"location":"about/#source-structure","text":".github/ -> Github files cmake/ -> Global CMake includes docs/ -> MkDocs documentation files lib/ -> Project libraries protocol/ -> Shared (between agent, server, webapp) protocol files server/ -> Collab3 server api/ -> API module core/ -> Core library config/ http/ util/ host/ -> Temp host webapp/ -> Webapp","title":"Source Structure"},{"location":"building/","text":"Compiling the Collab3 monorepo code is fairly easy. Notice Windows is not supported by the Collab3 developers, and the project will not configure if targeting a Windows platform. This is an intentional change, and it will not be reverted until: DBus p2p works on Windows Windows QEMU supports modules, and passing handles to and from QEMU and another process Dependencies GCC 11+ or Clang 14+ are recommended compiler versions, however newer versions are acceptable too. Libraries: Boost 1.75 or above fmt spdlog You can use either system library versions (if preferred) or use vcpkg for the grunt of them. Building Collab3 Monorepo C++ Code The general formula is: $ cmake -B build --preset $PRESET $ cmake --build build # ... # profit? where $PRESET can be: release : Release build debug : Debug build debug-asan : Debug build (with AddressSanitizer enabled) debug-tsan : Debug build (with ThreadSanitizer enabled) There are also a few others, but they are only for use by our CI, and shouldn't be used. To use vcpkg, add --toolchain $VCPKG/scripts/buildsystems/vcpkg.cmake to the CMake generation command line. For now, you'll get one collab3-host executable in the build root. This is the one you should run. Building Collab3 Monorepo Documentation Note that usually you won't have to do this, as the web documentation will update upon any changes to the documentation in the master branch. For development/local purposes, though: Prerequisites mkdocs Run mkdocs build . The resulting output will be in site/ , and you can host this wherever you want.","title":"Building Collab3"},{"location":"building/#notice","text":"Windows is not supported by the Collab3 developers, and the project will not configure if targeting a Windows platform. This is an intentional change, and it will not be reverted until: DBus p2p works on Windows Windows QEMU supports modules, and passing handles to and from QEMU and another process","title":"Notice"},{"location":"building/#dependencies","text":"GCC 11+ or Clang 14+ are recommended compiler versions, however newer versions are acceptable too. Libraries: Boost 1.75 or above fmt spdlog You can use either system library versions (if preferred) or use vcpkg for the grunt of them.","title":"Dependencies"},{"location":"building/#building-collab3-monorepo-c-code","text":"The general formula is: $ cmake -B build --preset $PRESET $ cmake --build build # ... # profit? where $PRESET can be: release : Release build debug : Debug build debug-asan : Debug build (with AddressSanitizer enabled) debug-tsan : Debug build (with ThreadSanitizer enabled) There are also a few others, but they are only for use by our CI, and shouldn't be used. To use vcpkg, add --toolchain $VCPKG/scripts/buildsystems/vcpkg.cmake to the CMake generation command line. For now, you'll get one collab3-host executable in the build root. This is the one you should run.","title":"Building Collab3 Monorepo C++ Code"},{"location":"building/#building-collab3-monorepo-documentation","text":"Note that usually you won't have to do this, as the web documentation will update upon any changes to the documentation in the master branch. For development/local purposes, though:","title":"Building Collab3 Monorepo Documentation"},{"location":"building/#prerequisites","text":"mkdocs Run mkdocs build . The resulting output will be in site/ , and you can host this wherever you want.","title":"Prerequisites"},{"location":"devguidelines/","text":"Development guidelines These are some guidelines for code which is part of the repo. Javascript To be written, but for now don't write some IE8 tier stuff. C++ Formatting Use clang-format. Naming Use .cpp for source files, .hpp for headers. Inline functions do NOT need another implementation file. Function and type names should be in PascalCase. Variable names are camelCase. Underscores should only be used very rarely for private/introspection only fields which need to be public (for instance; in classes which need to stay POD), as they risk UB. Class members have no special prefix (because if you're not sure, you can use this-> or the instance to qualify name lookup). Example (unformatted because I'm lazy): struct MyStructure { void DoThing(); private: std::uint32_t thing{}; std::uint32_t otherThing{}; }; void FreeFunction(); Language Subset The Collab3 C++ code uses the C++ language, obviously, but we do not use some of the features of the C++ language. The later sections describe our C++ language subset in depth. Exceptions Exceptions and the throw keyword are banned wholly in the collab3 C++ code. Rather: Non-fatal errors are collab3::core::Result<Value, Error> , which can also return/hold success cases (it's also cheap to pass, and doesn't allocate anything, unlike exceptions). One can handle errors without worrying about the logic being complicated ala: auto myResult = co_await MyCoroutineWhichRettysAResult(...); myResult.Map([](auto& res) { // My coroutine worked }).MapError([](auto& err) { // It did not. }).OrElse([]() { // Something went *hideously* wrong and the Result was defaulted. // (shouldn't need this case in most cases in \"good\" code.) }); Fatal errors should call collab3::core::Panic() with an optional message. The affected service will shut down with a message and print a stack trace (with symbolized names in Debug builds). COLLAB3_CORE_ASSERT(...) and COLLAB3_CORE_VERIFY(...) both call Panic() upon failure. _EXPECT(..., ErrorType, ...) variants will instead return a Result initialized with an ErrorType . Exceptions to this rule: - Constant expressions are allowed to use the throw keyword to induce compile time errors, as this is pretty much the only way to cleanly do so. Any code which currently throws before this rule was documented (refactor it out!!!) RTTI Native RTTI is banned, and we use a sort-of-ala LLVM-open-style RTTI system.","title":"Development Guidelines"},{"location":"devguidelines/#development-guidelines","text":"These are some guidelines for code which is part of the repo.","title":"Development guidelines"},{"location":"devguidelines/#javascript","text":"To be written, but for now don't write some IE8 tier stuff.","title":"Javascript"},{"location":"devguidelines/#c","text":"","title":"C++"},{"location":"devguidelines/#formatting","text":"Use clang-format.","title":"Formatting"},{"location":"devguidelines/#naming","text":"Use .cpp for source files, .hpp for headers. Inline functions do NOT need another implementation file. Function and type names should be in PascalCase. Variable names are camelCase. Underscores should only be used very rarely for private/introspection only fields which need to be public (for instance; in classes which need to stay POD), as they risk UB. Class members have no special prefix (because if you're not sure, you can use this-> or the instance to qualify name lookup). Example (unformatted because I'm lazy): struct MyStructure { void DoThing(); private: std::uint32_t thing{}; std::uint32_t otherThing{}; }; void FreeFunction();","title":"Naming"},{"location":"devguidelines/#language-subset","text":"The Collab3 C++ code uses the C++ language, obviously, but we do not use some of the features of the C++ language. The later sections describe our C++ language subset in depth.","title":"Language Subset"},{"location":"devguidelines/#exceptions","text":"Exceptions and the throw keyword are banned wholly in the collab3 C++ code. Rather: Non-fatal errors are collab3::core::Result<Value, Error> , which can also return/hold success cases (it's also cheap to pass, and doesn't allocate anything, unlike exceptions). One can handle errors without worrying about the logic being complicated ala: auto myResult = co_await MyCoroutineWhichRettysAResult(...); myResult.Map([](auto& res) { // My coroutine worked }).MapError([](auto& err) { // It did not. }).OrElse([]() { // Something went *hideously* wrong and the Result was defaulted. // (shouldn't need this case in most cases in \"good\" code.) }); Fatal errors should call collab3::core::Panic() with an optional message. The affected service will shut down with a message and print a stack trace (with symbolized names in Debug builds). COLLAB3_CORE_ASSERT(...) and COLLAB3_CORE_VERIFY(...) both call Panic() upon failure. _EXPECT(..., ErrorType, ...) variants will instead return a Result initialized with an ErrorType . Exceptions to this rule: - Constant expressions are allowed to use the throw keyword to induce compile time errors, as this is pretty much the only way to cleanly do so. Any code which currently throws before this rule was documented (refactor it out!!!)","title":"Exceptions"},{"location":"devguidelines/#rtti","text":"Native RTTI is banned, and we use a sort-of-ala LLVM-open-style RTTI system.","title":"RTTI"},{"location":"usage/","text":"TODO This page is under construction","title":"Collab3 Setup"},{"location":"usage/#todo","text":"This page is under construction","title":"TODO"}]}